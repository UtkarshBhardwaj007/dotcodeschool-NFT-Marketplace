This repository contains my solution to DotCodeSchool's Substrate Collectables Workshop.

## 1. Goal
* The goal is to create a custom Polkadot SDK Pallet that acts as an NFT Marketplace. Our NFTs will represent kitties, which will be a digital pets that can be created, traded, and more.
* This Pallet could then be included into a Polkadot SDK blockchain and used to launch a Web3 application on the Polkadot Network.

## 2. Runtime
* At the heart of a blockchain is a state transition function (STF). This is the logic of the blockchain, and defines all the ways a blockchain is allowed to manipulate the blockchain state.
* In the polkadot-sdk we refer to this logic as the blockchain's `runtime`.

## 3. NFTs
Non-Fungible Tokens (NFTs) are a type of token which can be created and traded on a blockchain. As their name indicated, each NFT is totally unique, and therefore non-fungible with one another. NFTs can be used for many things, for example: Representing real world assets, Ownership Rights, Access Rights, Digital assets, Music, Images etc.

## 4. Macros in FRAME
* **FRAME** uses Macros to simplify the development of Pallets, while keeping all of the benefits of using Rust. You can identify most macros in one of two forms:
  * `#[macro_name]`: **Attribute macros***, which are applied on top of valid rust syntax.
  * `macro_name!(...)`: **Declarative macros**, which can define their own internal syntax.
* The entrypoint for all the `FRAME` macros looks like this:

  ```rust
    #[frame::pallet(dev_mode)]
    pub mod pallet {
        // -- snip --
    }
  ```

* We wrap all of our Pallet code inside of this entrypoint, which allows our macros to have context of all the details inside. Without this, there would be no way for the macros defined inside the entry point to to communicate information to one another.
The unfortunate limitation here is that wherever we want to use `FRAME` macros, we must basically do it in a single file and all enclosed by the `#[frame::pallet]` macro entrypoint.

## 5. Basic Pallet Structure

```rust
    use frame::prelude::*;
    pub use pallet::*;

    #[frame::pallet]
    pub mod pallet {
        use super::*;

        #[pallet::pallet]
        pub struct Pallet<T>(core::marker::PhantomData<T>);

        #[pallet::config]  // snip
        #[pallet::event]   // snip
        #[pallet::error]   // snip
        #[pallet::storage] // snip
        #[pallet::call]    // snip
    }
```

### 5.1 Pallet Struct (`#[pallet::pallet]`)
* The Pallet struct is the anchor on which we implement all logic and traits for our Pallet.

```rust
    #[pallet::pallet]
    pub struct Pallet<T>(core::marker::PhantomData<T>);

    // Function implementations
    impl<T: Config> Pallet<T> {
        // -- snip --
    }

    // Trait implementations
    impl<T: Config> Hooks for Pallet<T> {
        fn on_finalize() {
            // -- snip --
        }
    }

    ...

    // And we can access these functions inside trait implementations as follows:
    pallet_kitties::Pallet::<T>::on_finalize();
```

* In fact, many traits are automatically implemented on top of `Pallet` and are accessible thanks to the `#[pallet::pallet]` attribute macro. You can see all the different traits implemented on Pallet by looking at the **autogenerated Rust docs**.
