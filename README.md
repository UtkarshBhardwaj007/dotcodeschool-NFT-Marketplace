This repository contains my solution to DotCodeSchool's Substrate Collectables Workshop.

## 1. Goal
* The goal is to create a custom Polkadot SDK Pallet that acts as an NFT Marketplace. Our NFTs will represent kitties, which will be a digital pets that can be created, traded, and more.
* This Pallet could then be included into a Polkadot SDK blockchain and used to launch a Web3 application on the Polkadot Network.

## 2. Runtime
* At the heart of a blockchain is a state transition function (STF). This is the logic of the blockchain, and defines all the ways a blockchain is allowed to manipulate the blockchain state.
* In the polkadot-sdk we refer to this logic as the blockchain's `runtime`.

## 3. NFTs
Non-Fungible Tokens (NFTs) are a type of token which can be created and traded on a blockchain. As their name indicated, each NFT is totally unique, and therefore non-fungible with one another. NFTs can be used for many things, for example: Representing real world assets, Ownership Rights, Access Rights, Digital assets, Music, Images etc.

## 4. Macros in FRAME
* **FRAME** uses Macros to simplify the development of Pallets, while keeping all of the benefits of using Rust. You can identify most macros in one of two forms:
  * `#[macro_name]`: **Attribute macros***, which are applied on top of valid rust syntax.
  * `macro_name!(...)`: **Declarative macros**, which can define their own internal syntax.
* The entrypoint for all the `FRAME` macros looks like this:

  ```rust
    #[frame::pallet(dev_mode)]
    pub mod pallet {
        // -- snip --
    }
  ```

* We wrap all of our Pallet code inside of this entrypoint, which allows our macros to have context of all the details inside. Without this, there would be no way for the macros defined inside the entry point to to communicate information to one another.
The unfortunate limitation here is that wherever we want to use `FRAME` macros, we must basically do it in a single file and all enclosed by the `#[frame::pallet]` macro entrypoint.

## 5. Basic Pallet Structure

```rust
    use frame::prelude::*;
    pub use pallet::*;

    #[frame::pallet]
    pub mod pallet {
        use super::*;

        #[pallet::pallet]
        pub struct Pallet<T>(core::marker::PhantomData<T>);

        #[pallet::config]  // snip
        #[pallet::event]   // snip
        #[pallet::error]   // snip
        #[pallet::storage] // snip
        #[pallet::call]    // snip
    }
```

### 5.1 Pallet Struct (`#[pallet::pallet]`)
* The Pallet struct is the anchor on which we implement all logic and traits for our Pallet.

```rust
    #[pallet::pallet]
    pub struct Pallet<T>(core::marker::PhantomData<T>);

    // Function implementations
    impl<T: Config> Pallet<T> {
        // -- snip --
    }

    // Trait implementations
    impl<T: Config> Hooks for Pallet<T> {
        fn on_finalize() {
            // -- snip --
        }
    }

    ...

    // And we can access these functions inside trait implementations as follows:
    pallet_kitties::Pallet::<T>::on_finalize();
```

* In fact, many traits are automatically implemented on top of `Pallet` and are accessible thanks to the `#[pallet::pallet]` attribute macro. You can see all the different traits implemented on Pallet by looking at the **autogenerated Rust docs**.

### 5.2 Callable Functions (`#[pallet::call]`)
There are two types of functions exposed by Pallets:
* Internal Functions: Regular functions only callable from within the blockchain.
* Callable Functions: The way users interact with the blockchain is through transactions. Those transactions are processed, and then dispatched to callable functions within the blockchain.

#### 5.2.1 Pallet Call Macro
* `FRAME` allows you to create callable functions by introducing the `#[pallet::call]` macro on top of a normal function implementation code block.

```rust
    #[pallet::call]
    impl<T: Config> Pallet<T> {
        // All of the functions in this `impl` will be callable by users.
    }
```

* The macro enforces rules on how these functions should be defined. They are discussed in the following sections.
* **NOTE**: "Users submit an extrinsic to the blockchain, which is dispatched to a Pallet call."
* **NOTE**: An `extrinsic` is any message from the outside coming to the blockchain. A `transaction` is specifically a signed message coming from the outside.

#### 5.2.2 Origin
* The first parameter of every callable function must be `origin: OriginFor<T>`.
* It describes where the call is calling from, and allows us to perform simple access control logic based on that information.
* The most common origin is the signed origin, which is a regular transaction.
* Origin is a superset of the idea of `msg.sender` (from Smart contract development). No longer do we need to assume that every call to a callable function is coming from an external account. We could have pallets call one another, or other internal logic trigger a callable function.

#### 5.2.3 Dispatch Result
* Every callable function must return a DispatchResult, which is simply defined as:

```rust
    pub type DispatchResult = Result<(), sp_runtime::DispatchError>;
```

* So these functions can return `Ok(())` or some `Err(DispatchError)`. You can easily define new `DispatchError` variants using the included `#[pallet::error]`.

### 5.3 Pallet Config (`#[pallet::config]`)
* Each pallet includes a **trait** `Config` which is used to configure the pallet in the context of your larger runtime.

```rust
    #[pallet::config]
    pub trait Config: frame_system::Config {
        // -- snip --
    }
```

* Wherever you see `T` (from `<T: Config>`), you have access to our `trait Config` and the types and functions inside of it.

### 5.4 Pallet Events (`#[pallet::event]`)
* Events allow Pallets to express that something has happened, and allows off-chain systems like indexers or block explorers to track certain state transitions.
* The `#[pallet::event]` macro acts on an enum Event.

```rust
    #[pallet::event]
    #[pallet::generate_deposit(pub(super) fn deposit_event)]
    pub enum Event<T: Config> {
        Created { owner: T::AccountId },
    }
```

* The macro `#[pallet::generate_deposit(pub(super) fn deposit_event)]` generates a helper function that handles event conversion and system integration.

```
Pallet Event                              // Your event
    ↓ (From conversion)
Pallet's Runtime Event                    // Runtime-level event
    ↓ (Into conversion)
frame_system::Config::RuntimeEvent        // System-level event
    ↓
Stored in block's event log
```
